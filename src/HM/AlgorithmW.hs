-- {-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables #-}
-- {-# LANGUAGE InstanceSigs #-}

module HM.AlgorithmW where

-- This is a context-insensitive bottom-up approch to type checking
-- The pros are:
--     1. That most of the times, the algorithm is capable of
--        deriving the types of the expression if it is indeed well typed
--     2. It is decidable (for most of the cases) and
--         terminates in polynomial time
-- The cons are:
--     1. It terminates too late into the type checking process if the
--        term is ill-typed
--     2. Error messages generated by the algorithm are not
--        very easy to understand for the programmer.
--     3. Constraint solving and traversal of AST is combined
--        This makes it non-modular

-- References:
-- 1. Principle Type Schemes for Functional Programs
--    https://dl.acm.org/citation.cfm?id=582176
-- 2. http://dev.stephendiehl.com/fun/006_hindley_milner.html
-- 3. https://github.com/quchen/articles/tree/master/hindley-milner
-- 4. Proofs about a folklore let-polymorphic type inference algorithm
--    https://dl.acm.org/citation.cfm?id=291892

import HM.Language
import HM.Util
import HM.Unify

import Control.Monad.State
import Debug.Trace (trace)


-- Algorithm W should assign the most general type for the expression i.e.
-- it should generate a Principal Type Scheme when
-- given a context or should fail with an error
algoW :: Context -> ExpFn -> TCM (Type, Substitution)
-- Our Exp can be of 5 types EVar, ELit, ELam, EApp, ELet
-- so we simply patten match on each constructor type and start assigning
-- types
{-
   The first rule is for the literals,
   literals have a constant type. eg. True: Bool 0: Int
   and require no substitution

  -------------------------------------------[Lit]
               Γ ⊢ True : TBool

  -------------------------------------------[Lit]
               Γ ⊢ 3 : TInt

-}

algoW gamma (ELit x) = do case x of
                            LitB _ -> return (TConst TBool, mempty)
                            LitI _ -> return (TConst TInt, mempty)

{-
   The second rule is for the variable
      x : σ ϵ Γ            τ = instantiate(σ)
   -------------------------------------------[Var]
               Γ ⊢ x : τ

  search if the variable x exists in the context Γ and instantiate it.
  return an error if no such variable exists

-}

algoW gamma (EVar x) = do sig <- lookupVar gamma x              -- x : σ ϵ Γ
                          tau <- instantiate sig                -- τ = inst(σ)
                          return (tau, mempty)                  -- τ

{-
  This rule types lambda expression.
          Γ, x:T ⊢ e :T'
   -------------------------- [Lam]
       Γ ⊢ λx. e : T -> T'

  A new type variable is introduced that is bound to lambda and
  it is added on to the context Γ, the expression is then checked for
  its type and

-}
algoW gamma (ELam x e) = do x' <- fresh 'x'                             -- x:T
                            let gamma' =                                -- Γ, x:T
                                  updateContext gamma x (scheme x')
                            (ty, s) <- algoW gamma' e                   -- e: T'
                            return (TArr (substitute s x') ty, s)        -- T -> T'

{-
   rule for application goes as follows:
   if we have an expression e e'
   then if the second expression e is well typed to T
   and the first expression should be of the form T -> T'
   then complete expression is of type T'


      Γ ⊢ e : T -> T'    Γ ⊢ e' :T
   --------------------------------------- [App]
                 Γ ⊢ e e' : T'


  The interesting bit here is we have to introduce a new
  type variable as the return type of the first expression
  and then fire unify to ensure the complete expression is well typed
-}
algoW gamma (EApp fn arg) = do (fty, s)  <- algoW gamma fn                         -- Γ ⊢ e : T -> T'
                               (aty, s') <- algoW (substitute s gamma) arg         -- Γ ⊢ e' :T
                               rty <- fresh 'e'
                               s'' <- unify (substitute s' fty) (TArr aty rty) 
                               return (substitute s'' rty, substitute s'' (substitute s' s))


{-
    Let bindings introduce variable names and associated types
    into the context Γ.

    The procedure for this rule is:
    - Obtain the type of e and bind it to x
    - then type check e' with the updated context

       Γ ⊢ e : T    sig = gen(Γ,T)    Γ, x: sig ⊢ e' :T'
   -------------------------------------------------------- [Let]
                  Γ ⊢ let x = e in e' : T'



-}
algoW gamma (ELet n e e') = do (ty, s) <- algoW gamma e                  -- Γ ⊢ e : T
                               sig <- generalize gamma ty
                               let gamma'' = updateContext gamma n sig   -- Γ, n: sig
                               (ty', s') <- algoW gamma'' e'             -- Γ, x: sig ⊢ e' :T'
                               return (ty', substitute s s')

{-

       Γ ⊢ c : Bool    Γ ⊢ e1 :T  Γ ⊢ e1 :T 
   -------------------------------------------------------- [Let]
      Γ, c:Bool, e1: T, e2: T ⊢ if c then e1 else e2 : T


-}
algoW gamma (EIf c e1 e2) = do (ty1, s1) <- algoW gamma e1                   -- Γ ⊢ e1 : T2
                               (ty2, s2) <- algoW gamma e2                   -- Γ ⊢ e2 : T3
                               s12 <- unify ty1 ty2                          -- T2 = T3
                               let s = substitute s12 (substitute s2 s1)
                               (b, s') <- algoW (substitute s gamma)  c        -- Γ ⊢ c : T1
                               s''  <- unify b (TConst TBool)                  -- T1 = Bool
                               let s''' =  substitute s'' (substitute s' s)
                               return (substitute s''' ty1,  s''')



{-

                 Γ, f: T -> T' ⊢ (λx. e) : T -> T'
   -------------------------------------------------------- [Let]
                 Γ ⊢ letrec f (λx. e) : T -> T'


-}

algoW gamma (EFix f l@(ELam _ _)) = do b <- fresh 'f'                                       -- f: T
                                       let gamma' = updateContext gamma f (scheme b)        -- Γ, f:T
                                       (ty, s) <- algoW gamma' l                            -- Γ, f:T ⊢ l : T'
                                       s' <- unify (substitute s b) ty
                                       return (substitute s' ty, substitute s' s)

algoW _ e  = typeError $ "Cannot infer type: " ++ show e
