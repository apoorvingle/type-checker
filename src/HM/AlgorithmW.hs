{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE InstanceSigs #-}

module HM.AlgorithmW where

-- This is a context-insensitive bottom-up approch to type checking
-- The pros are:
--     1. That most of the times, the algorithm is capable of
--        deriving the types of the expression if it is indeed well typed
--     2. It is decidable (for most of the cases) and
--         terminates in polynomial time
-- The cons are:
--     1. It terminates too late into the type checking process if the
--        term is ill-typed
--     2. Error messages generated by the algorithm are not
--        very easy to understand for the programmer.
--     3. Constraint solving and traversal of AST is combined
--        This makes it non-modular

-- References:
-- 1. Principle Type Schemes for Functional Programs
--    https://dl.acm.org/citation.cfm?id=582176
-- 2. http://dev.stephendiehl.com/fun/006_hindley_milner.html
-- 3. https://github.com/quchen/articles/tree/master/hindley-milner
-- 4. Proofs about a folklore let-polymorphic type inference algorithm
--    https://dl.acm.org/citation.cfm?id=291892

import HM.Language
import HM.Util

import Control.Monad.State


-- Unify is a function that tries to unify 2 types or returns an error
-- The goal will be to convert left Type into a right Type
-- so that substitute t1 (unify (ty1, ty2)) = ty2 if unify returns a Right _
-- we need to update the state i.e. subs tcm and return a ()
unify :: Type ->  Type -> TCM ()
unify t1@(TArr a b) t2@(TArr c d) = do unify a c
                                       unify c d

unify (TVar a) x@(TVar b)         | (a == b) = return ()
                                  | otherwise =  do modify (\tcs -> tcs {subs = subs tcs `mappend` (sub a x)})
unify x1@(TVar a) x          = do if (a `elem` fvs x)
                                    then typeError $ infiniteType x1 x
                                    else do modify (\tcs -> tcs {subs = subs tcs `mappend` (sub a x)})
unify x x1@(TVar a)          = do if (a `elem` fvs x)
                                    then typeError $ infiniteType x x1
                                    else do modify (\tcs -> tcs {subs = subs tcs `mappend` (sub a x)})
unify t1@(TConst a) t2@(TConst b) | (a == b)  = return ()
                            | otherwise = typeError $ cannotUnify t1 t2
unify t1@(TConst a)  b      = typeError $ cannotUnify t1 b

unify a b                   = typeError $ cannotUnify a b

infiniteType t1 t2 = "unification of "
                     ++ show t1 ++ " and " ++ show t2
                     ++ " will lead to infinite type"
cannotUnify t1 t2 = "Cannot unify " ++ (show t1) ++ " and " ++ (show t2)



-- Algorithm W should assign the most general type for the expression i.e.
-- it should generate a Principal Type Scheme when
-- given a context or should fail with an error
algoW :: Context -> ExpFn -> TCM (Type, Substitution)
-- Our Exp can be of 5 types EVar, ELit, ELam, EApp, ELet
-- so we simply patten match on each constructor type and start assigning
-- types
{-
   The first rule is for the literals,
   literals have a constant type. eg. True: Bool 0: Int
   and require no substitution

  -------------------------------------------[Lit]
               Γ ⊢ True : TBool

  -------------------------------------------[Lit]
               Γ ⊢ 3 : TInt

-}

algoW gamma (ELit x) = do case x of
                            LitB _ -> return $ (TConst TBool, mempty)
                            LitI _ -> return $ (TConst TInt, mempty)

{-
   The second rule is for the variable
      x : σ ϵ Γ            τ = instantiate(σ)
   -------------------------------------------[Var]
               Γ ⊢ x : τ

  search if the variable x exists in the context Γ and instantiate it.
  return an error if no such variable exists

-}

algoW gamma (EVar x) = do sig <- lookupVar gamma x              -- x : σ ϵ Γ
                          tau <- instantiate sig                -- τ = inst(σ)
                          return (tau, mempty)                  -- τ

{-
  This rule types lambda expression.
          Γ, x:T ⊢ e :T'
   -------------------------- [Lam]
       Γ ⊢ λx. e : T -> T'

  A new type variable is introduced that is bound to lambda and
  it is added on to the context Γ, the expression is then checked for
  its type and

-}
algoW gamma (ELam x e) = do x' <- fresh 'x'                             -- x:T
                            let gamma' =                                -- Γ, x:T
                                  updateContext gamma x (scheme x')
                            (ty, s) <- algoW gamma' e                   -- e: T'
                            return (TArr (substitute s x') ty, s)        -- T -> T'

{-
   rule for application goes as follows:
   if we have an expression e e'
   then if the second expression e is well typed to T
   and the first expression should be of the form T -> T'
   then complete expression is of type T'


      Γ ⊢ e : T -> T'    Γ ⊢ e' :T
   --------------------------------------- [App]
                 Γ ⊢ e e' : T'


  The interesting bit here is we have to introduce a new
  type variable as the return type of the first expression
  and then fire unify to ensure the complete expression is well typed
-}
algoW gamma (EApp e e') = do (ty, s)  <- algoW gamma e                         -- Γ ⊢ e : T -> T'
                             (ty', s') <- algoW (substitute s gamma) e'        -- Γ ⊢ e' :T
                             f <- fresh 'f'
                             unify (substitute s' ty) (TArr ty' f)
                             s'' <- get
                             let subst = subs s''
                             return $ ((substitute subst f), (subst `mappend` s' `mappend` s))


{-
    Let bindings introduce variable names and associated types
    into the context Γ.

    The procedure for this rule is:
    - Obtain the type of e and bind it to x
    - then type check e' with the updated context

       Γ ⊢ e : T    sig = gen(Γ,T)    Γ, x: sig ⊢ e' :T'
   -------------------------------------------------------- [Let]
                  Γ ⊢ let x = e in e' : T'



-}
algoW gamma (ELet n e e') = do (ty, s) <- algoW gamma e                  -- Γ ⊢ e : T
                               sig <- generalize gamma ty
                               let gamma'' = updateContext gamma n sig   -- Γ, n: sig
                               (ty', s') <- algoW gamma'' e'             -- Γ, x: sig ⊢ e' :T'
                               return (ty', s `mappend` s')

{-

       Γ ⊢ c : Bool    Γ ⊢ e1 :T  Γ ⊢ e1 :T 
   -------------------------------------------------------- [Let]
      Γ, c:Bool, e1: T, e2: T ⊢ if c then e1 else e2 : T


-}
algoW gamma (EIf c e1 e2) = do (ty, s) <- algoW gamma c                  -- Γ ⊢ c : T1
                               (ty1, s1) <- algoW gamma e1               -- Γ ⊢ e1 : T2
                               (ty2, s2) <- algoW gamma e2               -- Γ ⊢ e2 : T3
                               unify ty1 ty2                             -- T2 = T3
                               unify ty (TConst TBool)                   -- T1 = Bool
                               return (ty1, s `mappend` s1 `mappend` s2)



-- This is a mess
algoW gamma (EFix f l@(ELam x e)) = do b <- fresh 'f'                                       -- f: T
                                       let gamma' = updateContext gamma f (scheme b)        -- Γ, f:T
                                       (ty, s) <- algoW gamma' l                            -- Γ, f:b ⊢ l : T'
                                       unify (substitute s b) ty
                                       tcst <- get
                                       let s' = subs tcst
                                       return (ty, s')

algoW _ e  = typeError $ "Cannot infer type: " ++ show e
